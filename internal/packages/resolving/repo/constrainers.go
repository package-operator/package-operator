package repo

import (
	"fmt"

	"github.com/operator-framework/deppy/pkg/deppy"
	"github.com/operator-framework/deppy/pkg/deppy/constraint"

	"package-operator.run/internal/packages/resolving/solver"
)

type CandiadateNameVersionAccessor interface {
	solver.CandidateData
	CandidatePackageName() string
	CandidatePackageVersion() solver.Version
}

// SingleCandidateVersionInScope prohibits all other [Candidate] in the same [Scope] that have the same
// as the associated one except the one that has same version as it (it does not conflict with itself).
func SingleCandidateVersionInScope[IM solver.InstallationData, SM solver.ScopeData, CM CandiadateNameVersionAccessor](us solver.CandidateAccessor[IM, SM, CM]) []solver.Constraint {
	constraints := []solver.Constraint{}

	ourReference := us.CandidateData().CandidatePackageName()
	ourVersion := us.CandidateData().CandidatePackageVersion()

	for _, other := range us.CandidateScopeAccessor().ScopeCandidateAccessors() {
		otherVersion := other.CandidateData().CandidatePackageVersion()
		otherReference := other.CandidateData().CandidatePackageName()

		switch {
		case ourReference == otherReference && ourVersion.Equal(&otherVersion):
			// Other is us, we do not want to conflict with ourselves.
		case ourReference == otherReference:
			// Other matches our package.
			constraints = append(constraints, constraint.Conflict(other.CandidateData().CandidateIdentifier()))
		default:
			// We do not care about the other package.
		}
	}

	return constraints
}

// CandidateConflictsWithCandidateInSameScope lets the associated [Candidate] create a conflict with all Candidates in the same [Scope] with the
// name denoted in parameter name and matched by the version range versionRange. No conflict may happen for the Candidates to be able to be installed.
func CandidateConflictsWithCandidateInSameScope[IM solver.InstallationData, SM solver.ScopeData, CM CandiadateNameVersionAccessor](conflictingName string, conflictingVersionRange solver.VersionRange) solver.CandidateConstrainer[IM, SM, CM] {
	return func(us solver.CandidateAccessor[IM, SM, CM]) []solver.Constraint {
		constraints := []solver.Constraint{}

		ourName := us.CandidateData().CandidatePackageName()
		ourVersion := us.CandidateData().CandidatePackageVersion()

		for _, other := range us.CandidateScopeAccessor().ScopeCandidateAccessors() {
			otherName := other.CandidateData().CandidatePackageName()
			otherVersion := other.CandidateData().CandidatePackageVersion()

			switch {
			case ourName == otherName && ourVersion.Equal(&otherVersion):
				// Other is us, we do not want to conflict with ourselves.
			case conflictingName == otherName && conflictingVersionRange.Check(&otherVersion):
				// Other matches conflicting package reference and conflicting version range.
				constraints = append(constraints, constraint.Conflict(other.CandidateData().CandidateIdentifier()))
			default:
				// We do not care about the other package.
			}
		}

		return constraints
	}
}

// CandidateDependsOnCandidateInSameScope lets the associated [Candidate] create a dependency to a Candidate in the same [Scope] with the
// name denoted in parameter name and matched by the version range versionRange. At least one of the Candidates must be installed to allow
// this Canidate itself to be installed.
func CandidateDependsOnCandidateInSameScope[IM solver.InstallationData, SM solver.ScopeData, CM CandiadateNameVersionAccessor](name string, versionRange solver.VersionRange) solver.CandidateConstrainer[IM, SM, CM] {
	return func(c solver.CandidateAccessor[IM, SM, CM]) []deppy.Constraint {
		// The constraints generated by ScopeInstalls are like a dependency when they are attached to a Candidate instead of a Scope.
		return ScopeInstallsCandidate[IM, SM, CM](name, versionRange)(c.CandidateScopeAccessor())
	}
}

// ScopeInstallsCandidate lets the [Scope] install a [Candidate] with the name denoted in parameter name and the version matched
// by versionRange in the Scope. At least one of the Candidates must be installed to solve the Scope.
func ScopeInstallsCandidate[IM solver.InstallationData, SM solver.ScopeData, CM CandiadateNameVersionAccessor](name string, versionRange solver.VersionRange) solver.ScopeConstrainer[IM, SM, CM] {
	return func(s solver.ScopeAccessor[IM, SM, CM]) []solver.Constraint {
		// Get solver variable IDs for all packages that fit the version constraint.
		selectIDs := []deppy.Identifier{}
		discardedVersions := []string{}
		for _, candidate := range s.ScopeCandidateAccessors() {
			currentName := candidate.CandidateData().CandidatePackageName()
			currentVersion := candidate.CandidateData().CandidatePackageVersion()
			switch {
			case name != currentName:
				// Wrong package reference.
				continue
			case versionRange.Check(&currentVersion):
				// Right package reference and matching version.
				selectIDs = append(selectIDs, candidate.CandidateData().CandidateIdentifier())
			default:
				// Right package reference but version does not match.
				discardedVersions = append(discardedVersions, currentVersion.String())
			}
		}

		switch {
		case len(selectIDs) != 0:
			// There are candidates.
			return []solver.Constraint{constraint.Dependency(selectIDs...)}
		case len(discardedVersions) != 0:
			// There are candidates for the package reference that were discarded by the version constraint.
			formatter := func(_ deppy.Constraint, subject deppy.Identifier) string {
				return fmt.Sprintf("%s requires package %s with version constraint %s but no available version out of %v satisfies this", subject, name, versionRange.String(), discardedVersions)
			}
			return []solver.Constraint{constraint.NewUserFriendlyConstraint(constraint.Prohibited(), formatter)}
		default:
			// There is no canidate for the package reference.
			formatter := func(_ solver.Constraint, subject deppy.Identifier) string {
				return fmt.Sprintf("%s requires package %s which has no candidates", subject, name)
			}
			return []solver.Constraint{constraint.NewUserFriendlyConstraint(constraint.Dependency(), formatter)}
		}
	}
}

// InstallationForbidCandidate denotes that the [Installation] forbids any [Candidate] that has the name denoted in the parameter name
// and gets its version matched by the version range of parameter versionConstraint.
func InstallationForbidsCandidate[IM solver.InstallationData, SM solver.ScopeData, CM CandiadateNameVersionAccessor](name string, versionRange solver.VersionRange) solver.InstallationConstrainer[IM, SM, CM] {
	return func(i solver.InstallationAccessor[IM, SM, CM]) []solver.Constraint {
		cns := []solver.Constraint{}
		for _, scope := range i.InstallationScopes() {
			cns = append(cns, ScopeForbidsCandidate[IM, SM, CM](name, versionRange)(scope)...)
		}

		return cns
	}
}

// ScopeForbidsCandidate denotes that the [Scope] forbids [Candidate] that has the name denoted in the parameter forbiddenCandidateName
// and gets its version matched by the version range of parameter forbiddenVersionRange in it.
func ScopeForbidsCandidate[IM solver.InstallationData, SM solver.ScopeData, CM CandiadateNameVersionAccessor](forbiddenName string, forbiddenVersionRange solver.VersionRange) solver.ScopeConstrainer[IM, SM, CM] {
	return func(s solver.ScopeAccessor[IM, SM, CM]) []solver.Constraint {
		cns := []solver.Constraint{}
		for _, candidate := range s.ScopeCandidateAccessors() {
			name := candidate.CandidateData().CandidatePackageName()
			version := candidate.CandidateData().CandidatePackageVersion()
			if forbiddenName == name && forbiddenVersionRange.Check(&version) {
				formatter := func(_ deppy.Constraint, subject deppy.Identifier) string {
					return fmt.Sprintf("%s prohibits package %s in version range %s", subject, forbiddenName, forbiddenVersionRange.String())
				}
				cns = append(cns, constraint.NewUserFriendlyConstraint(constraint.Conflict(candidate.CandidateData().CandidateIdentifier()), formatter))
			}
		}

		return cns
	}
}
